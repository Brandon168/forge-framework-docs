{"name":"Forge-framework-docs","tagline":"Forge Framework Documentation","body":"Forge Framework\r\n===============\r\n\r\nForge Framework is an application level framework that runs on Zend Framework 2. The purpose of Forge Framework is to\r\nprovide prebuilt application components, fully functional out of the box, with flexible customization strategies that\r\noffer full control to the user but do not break the upgrade path.\r\n\r\nZend Framework was chosen because of it's maturity, documentation, coding standards, loosely coupled libraries, and\r\nevent based MVC architecture. The event based architecture of ZF2 made it easy to introduce new Forge Framework\r\nfunctionality in a non intrusive way.\r\n\r\nA concerted effort was made to use Zend Framework 2 functionality as is where possible. All ZF2 documentation can be\r\nrelied upon to work with Forge Framework except where specifically noted. ZF2 community modules may be used directly\r\nwith Forge Framework. This is extremely useful for quickly testing ZF2 modules. However, to fully utilize Forge Framework's\r\nview building capabilities, some customization is required.\r\n\r\nForge Framework also shares many similarities with Magento. For example, the composite view strategy based in layout\r\nconfiguration files is based off of Magento's view strategy.\r\n\r\n##A Quick Walk Through\r\n\r\nForge Framework application flow is exactly that of ZF2 with a few additions. Below is a quick walk through of the\r\napplication flow.\r\n\r\nForge Framework implements the Front Controller pattern where all requests are routed through a single point. This is\r\nan example of an index.php file which handles all incoming requests.\r\n\r\n```php\r\n<?php\r\nuse Zend\\Config\\Config;\r\nuse Zend\\Mvc\\Application;\r\n\r\n/**\r\n * This makes our life easier when dealing with paths. Everything is relative\r\n * to the application root now.\r\n */\r\nchdir(dirname(__DIR__));\r\n\r\n// Setup autoloading\r\nrequire 'init_autoloader.php';\r\n\r\n// Configure the application\r\n$config = new Config(require 'config/application.global.php');\r\nif (file_exists('config/application.local.php')) {\r\n    $config->merge(new Config(require 'config/application.local.php'));\r\n}\r\n\r\n// Initialize and run the application\r\nApplication::init($config)->run();\r\n```\r\n\r\nLets break this file up into sections...\r\n\r\n###Autoloading\r\n\r\n```php\r\n<?php\r\n// Setup autoloading\r\nrequire 'init_autoloader.php';\r\n```\r\n\r\nForge Framework initially sets up autoloading based on composer configs and default loading for ZF2 and Forge Framework.\r\nLater in the application flow, modules add their autoload configuration as well.\r\n\r\n###Application Configuration\r\n\r\n```php\r\n<?php\r\n// Configure the application!\r\n$config = new Config(require 'config/application.global.php');\r\n```\r\n\r\nThis loads a global configuration file which is shared across all environments and is stored in version control. This\r\nconfiguration is the minimal configuration needed to load the application. All other configuration is done from within\r\nmodules. This tells the application what modules to load in what order. It also tells the application where to find\r\nother application config files, which directories to use for different things, whether to enable caching, etc.\r\n\r\n```php\r\n<?php\r\n// application.global.php\r\nreturn [\r\n    'modules' => [\r\n        'ForgeApplication',\r\n        'ForgeAcl',\r\n        'ForgeUser',\r\n        'ForgeAdmin',\r\n        'ForgeDeveloperTools',\r\n        'Application',\r\n    ],\r\n    'module_listener_options' => [\r\n        'config_cache_enabled' => false,\r\n        'cache_dir'            => 'data/cache',\r\n        'config_glob_paths'    => [\r\n            'config/autoload/{,*.}local.php',\r\n            'config/autoload/{,*.}global.php',\r\n        ],\r\n        'module_paths' => [\r\n            'module/core',\r\n            'module/thirdparty',\r\n            'module/local',\r\n        ],\r\n    ],\r\n];\r\n```\r\n\r\nAn environment specific file is then merged on top to allow for settings like enabling or disabling caching or enabling\r\ncss/js merging and minification.\r\n\r\n```php\r\n<?php\r\nif (file_exists('config/application.local.php')) {\r\n    $config->merge(new Config(require 'config/application.local.php'));\r\n}\r\n```\r\n\r\n```php\r\n<?php\r\n// application.local.php\r\nreturn [\r\n    'module_listener_options' => [\r\n        'config_cache_enabled' => false,\r\n    ],\r\n];\r\n```\r\n\r\nAll configuration merging is done with array_replace_recursive logic with one exception. If all indexes of an array\r\nare numeric, the second array is merged on top of the first instead like array_merge. This is done using ZF2's built in\r\nConfig class.\r\n\r\n###Initialization\r\n\r\nThe index file uses Application::init() to initialize the application. This is only a default configuration method for\r\nForge Framework. The tasks within Application::init() could be placed directly into index.php as well if customization\r\nis needed.\r\n\r\n```php\r\n<?php\r\n// Initialize and run the application\r\nApplication::init($config);\r\n```\r\n\r\n```php\r\n<?php\r\n// Zend\\Mvc\\Application\r\npublic static function init($configuration = array())\r\n{\r\n    $smConfig = isset($configuration['service_manager']) ? $configuration['service_manager'] : array();\r\n    $serviceManager = new ServiceManager(new Service\\ServiceManagerConfig($smConfig));\r\n    $serviceManager->setService('ApplicationConfig', $configuration);\r\n    $serviceManager->get('ModuleManager')->loadModules();\r\n\r\n    $listenersFromAppConfig     = isset($configuration['listeners']) ? $configuration['listeners'] : array();\r\n    $config                     = $serviceManager->get('Config');\r\n    $listenersFromConfigService = isset($config['listeners']) ? $config['listeners'] : array();\r\n\r\n    $listeners = array_unique(array_merge($listenersFromConfigService, $listenersFromAppConfig));\r\n\r\n    return $serviceManager->get('Application')->bootstrap($listeners);\r\n}\r\n```\r\n\r\nThis sets up the service manager, loads all modules, then bootstraps the application.\r\n\r\n####The Service Manager\r\n\r\nThe service manager is a service locator pattern. It also doubles as a dependency injection container. Through\r\nconfiguration, all classes and instances of classes can be substituted for others, initialized, run through factory\r\nconstructors, and aliased. By default, the same instance of a class is returned every time it is requested from the\r\nservice manager. A new object can be requested on demand. This effectively can be used as a singleton pattern as well.\r\n\r\nZF2 previous to initial release had a dedicated dependency injection implementation. This was deemed overcomplicated for\r\nthe average user to use or care about, but the service manager worked well enough and had a simple enough interface that\r\nit became a direct replacement. The service manager still falls back to the original dependency injection\r\nimplementation when no service configuration can be found. For more information on the service manager, read the\r\n[ZF2 documentation] (http://framework.zend.com/manual/2.3/en/modules/zend.service-manager.quick-start.html).\r\n\r\n####Module Loading\r\n\r\nModules are loaded in the order specified in the application configuration. This is event based.\r\n\r\nThese are the relevant events:\r\n\r\n* ModuleEvent::EVENT_LOAD_MODULES\r\n* ModuleEvent::EVENT_LOAD_MODULE\r\n* ModuleEvent::EVENT_LOAD_MODULES_POST\r\n\r\nThe following tasks are performed for each module, via events:\r\n\r\n(Not entirely sure on the order. Need to review)\r\n\r\n1. Load module config\r\n2. Set up module autoloaders\r\n3. Check module dependencies\r\n4. Run init() method on module\r\n5. Add service manager settings from module to main service manager\r\n6. Add module, itself, to the service manager\r\n7. Attach the onBootstrap() method of each module to the bootstrap event which will be run once all modules are loaded\r\n\r\n####Bootstrapping the Application\r\n\r\nThe application is bootstrapped once all modules are loaded and the configuration is complete. Routers are created based\r\non the router map from the config.\r\n\r\n```php\r\n<?php\r\n// Zend\\Application\\Application\r\npublic function bootstrap(array $listeners = array())\r\n{\r\n    $serviceManager = $this->serviceManager;\r\n    $events         = $this->events;\r\n\r\n    $listeners = array_unique(array_merge($this->defaultListeners, $listeners));\r\n\r\n    foreach ($listeners as $listener) {\r\n        $events->attach($serviceManager->get($listener));\r\n    }\r\n\r\n    // Setup MVC Event\r\n    $this->event = $event  = new MvcEvent();\r\n    $event->setTarget($this);\r\n    $event->setApplication($this)\r\n          ->setRequest($this->request)\r\n          ->setResponse($this->response)\r\n          ->setRouter($serviceManager->get('Router'));\r\n\r\n    // Trigger bootstrap events\r\n    $events->trigger(MvcEvent::EVENT_BOOTSTRAP, $event);\r\n    return $this;\r\n}\r\n```\r\n\r\nThis enables the default route, dispatch, and view listeners, sets up the MvcEvent, and triggers the bootstrap event.\r\nModules may implement an \"onBootstrap\" method. This method is run after the rest of the application has been initialized.\r\nThis is the point where modules have all access to everything they may need within the application. Most module\r\ninitialization should occur here.\r\n\r\n###Running the Application\r\n\r\n```php\r\n<?php\r\n// Zend\\Application\\Application\r\npublic function run()\r\n{\r\n    $events = $this->events;\r\n    $event  = $this->event;\r\n\r\n    // Define callback used to determine whether or not to short-circuit\r\n    $shortCircuit = function ($r) use ($event) {\r\n        if ($r instanceof ResponseInterface) {\r\n            return true;\r\n        }\r\n        if ($event->getError()) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n\r\n    // Trigger route event\r\n    $result = $events->trigger(MvcEvent::EVENT_ROUTE, $event, $shortCircuit);\r\n    if ($result->stopped()) {\r\n        $response = $result->last();\r\n        if ($response instanceof ResponseInterface) {\r\n            $event->setTarget($this);\r\n            $event->setResponse($response);\r\n            $events->trigger(MvcEvent::EVENT_FINISH, $event);\r\n            $this->response = $response;\r\n            return $this;\r\n        }\r\n        if ($event->getError()) {\r\n            return $this->completeRequest($event);\r\n        }\r\n        return $this;\r\n    }\r\n    if ($event->getError()) {\r\n        return $this->completeRequest($event);\r\n    }\r\n\r\n    // Trigger dispatch event\r\n    $result = $events->trigger(MvcEvent::EVENT_DISPATCH, $event, $shortCircuit);\r\n\r\n    // Complete response\r\n    $response = $result->last();\r\n    if ($response instanceof ResponseInterface) {\r\n        $event->setTarget($this);\r\n        $event->setResponse($response);\r\n        $events->trigger(MvcEvent::EVENT_FINISH, $event);\r\n        $this->response = $response;\r\n        return $this;\r\n    }\r\n\r\n    $response = $this->response;\r\n    $event->setResponse($response);\r\n    $this->completeRequest($event);\r\n\r\n    return $this;\r\n}\r\n```\r\n\r\n```php\r\n<?php\r\n// Zend\\Application\\Application\r\nprotected function completeRequest(MvcEvent $event)\r\n{\r\n    $events = $this->events;\r\n    $event->setTarget($this);\r\n    $events->trigger(MvcEvent::EVENT_RENDER, $event);\r\n    $events->trigger(MvcEvent::EVENT_FINISH, $event);\r\n    return $this;\r\n}\r\n```\r\n\r\nThe application is now set up and the request can be handled.\r\n\r\nThe first step is to attempt to route the request. The request URI is mapped to a route defined within the configuration.\r\nIf the URI cannot be mapped, a 404 page is served. The request may also directly lead to a redirect. If so, the redirect\r\nis issued immediately. If a controller action can be determined from the request, the application dispatches to the\r\ncontroller. If the controller action does not exist, a 404 page is served. If it does exist, the action is executed.\r\n\r\nThe controller action may return a number of different response types. Depending on the response returned, a specific\r\nlistener will pick the response up and process it.\r\n\r\nThese are the current possible return types and their behaviors:\r\n\r\n* null - A simple view object is constructed using the module, controller, and action name to grab a template\r\n* array() - The same view is constructed as null, except that the data provided in the array is made available as variables\r\n  in the view script.\r\n* JsonViewModel - Will be rendered directly as JSON\r\n* ViewModel - No post processing is done. The view model is rendered as is\r\n* CompositeViewModel - The view model is rendered via Forge Framework's composite view strategy\r\n* Response - If a direct response object is returned, it will be rendered directly as is without any rendering strategy\r\n\r\nThese views are rendered by listeners of the MvcEvent::EVENT_RENDER event. New listeners can be attached to watch for\r\ndifferent response types. For example, if xml output needed to be rendered, a listener could be registered to watch for\r\na return type of SimpleXml.\r\n\r\nFinally, the MvcEvent::EVENT_FINISH event fires. This handles the actual output to the browser. Headers are send first,\r\nthen, the output is sent.","google":"UA-33125875-11","note":"Don't delete this file! It's used internally to help with page regeneration."}